=RFC: New API to Unify WEXT (iwlibs) and nl80211 Interfaces in pythonwifi=

Started: 20110317
Rev. 20110318-01

This document attempts to outline a new API for pythonwifi going forward
from v0.5.  Everything in this Request For Commentis open for discussion
and change.  The API described here a starting point for such a discussion.
That argument will take place on pythonwifi-devel@berlios.de. If you would
like to comment on this API, please subscribe and become involved.


==Authors==

If you contribute to this RFC, by adding, removing, or editing content,
please add your name to the author list below.  Email addresses are optional.

Sean Robinson <seankrobinson@gmail.com>


==History==

pythonwifi in its current state is a pure Python distribution, developed
under Python 2, for controlling wireless network device configuration in
Linux systems using the WEXT ioctls.  The WEXT interface is the long-time
access method for configuration and control of wireless devices in the Linux
kernel (i.e. iwconfig and iwlist).  However, WEXT has been deprecated since
at least 2007 and nl80211 is the new interface that Linux kernel developers
are encouraging.

pymnl is a newly written pure Python distribution to aid communicating with
the Netlink system (which underlies the nl80211 protocol).  pymnl does not
know about nl80211, but it can be used as a foundation by pythonwifi to
add nl80211 access along with WEXT access.


==Future==

I am proposing that pythonwifi add nl80211 and clean up the existing API so
that a unified interface for WEXT and nl80211 will be possible.  This means
identifying those functions needed by pythonwifi users and providing those
functions using the same class and method naming for the WEXT and nl80211
modules.  One goal of this reorganizaion is that the module used may be
swapped out for the other module without requiring much, if any, other
changes to the user's source code.


==Terminology==

This document tries to follow the Python community conventions, as I
understand it, for terminology relating to software libraries.  The overall
group of files is a distribution, the distribution under consideration is
named pythonwifi.  A package is a subgroup of files within a distribution.
The root package is the top of the hierarchy and is the base of the
distribution.  The pythonwifi distribution will contain two packages
below the root package: nl80211 and wext.

A module is an individual file in the distribution.  This file may be within
a package or above the packages in the hierarchy but is still located within
the distribution.

Where pseudo-code is used to illustrate the proposed API, an informal data
type is used to hint at the values to be passed into and returned from the
method.  As Python is not a strongly-typed language, these types are only
used to indicate general data types.

The term "wireless client developers" is used to describe those programmers
controlling the wireless hardware via requests to the driver from userspace.
So the developers in question are requesting service from the wireless
driver.  This term is used to more clearly distinguish the pythonwifi target
audience from driver developers.


==New API==

===Distribution Layout===

The new module will be named pythonwifi.nl80211. The existing pythonwifi
module will be moved down to pythonwifi.wext.  That is, the current file
hierarchy will be changed from

        pythonwifi/__init__.py
to
        pythonwifi/nl80211/__init__.py
        pythonwifi/wext/__init__.py

This means the module(s) would be imported with:

        import pythonwifi.nl80211
        import pythonwifi.wext

Although, only one module should be required at one time.


===Module Layout===

The main package in each module will be __init__.py so that importing the
module will provide access to the primary class(es) to be used by wireless
client developers.  The package containing the most common constants used by
each protocol will be named flags.py.  The package containing common
utilities required for the protocol, but not necessarily needed by wireless
client developers, will be named base.py.  Each module may have additional
packages which provide additional protocol support.

        pythonwifi/(nl80211|wext)/__init__.py
        pythonwifi/(nl80211|wext)/flags.py
        pythonwifi/(nl80211|wext)/base.py


====Root Package Functions and Classes====

pythonwifi/__init__.py will contain utility functions useful to wireless
client developers that are not directly wireless oriented (e.g. retrieve
a list of NICs and wireless NICs or convert an interface name to its index).
These are not required to be in classes, but a group of functions may be
put into a class if it makes sense.

{{{
    def get_nic_names()
    def get_wnic_names()
    def get_phy_names()  XXX
    def get_wiphy_names()  XXX
    def if_nametoindex(string)

}}}

===Package Classes===

The primary classes of interest to pythonwifi users will be named Wireless
and Station.  These class names will be the same in the nl80211 and WEXT
modules.  Secondary classes for less common operations will be in the same
package.


====Wireless Class====

Note that the method names used below are a dramatic change from the current
method names used in pythonwifi <= 0.5.  One of the goals with this method
renaming is to make pythonwifi more compliant with PEP 8.

The methods included in the Wireless class should be only those most likely
to be useful for wireless client developers.  Therefor, all methods in
Wireless should operate in both the nl80211 and wext packages.  See
WirelessConfig for more commands.

{{{
class Wireless(object):
    """ Model of a wireless device.

        An exception may be raised if any of the following operations are
        attempted on a non-existant or unconfigured
        (i.e. ifconfig wlan0 down) device.
    """
    def __init__(ifname=None):
        """ Create a Wireless object.
            ifname - string - name of wireless interface to use (e.g. wlan0)
        """
        pass

    def scan(trigger=True, ssid=None, frequency=None, channel=None):
        """ Returns a list of ServiceSet objects.  These objects are built
            from the SSID information found in the local environment.

            trigger - boolean - True = ask wireless system to perform a new scan;
                                False = use information from previous scan

            ssid - string - look for this specific SSID

            frequency - integer - scan only on this frequency (freq in MHz)

            channel - integer - scan only on this channel; will look up the
                                associated frequency and use that for the scan

            If frequency and channel are both given, an exception is raised.
        """
        return ss_list

    def connect(ssid, bssid=None, frequency=None, channel=None):
        """ Connect with specified SSID.

            ssid - string - the SSID with which to connect

            bssid - string - specific BSSID in SSID with which to connect;
                             this string is six colon-separated octets
                             (e.g. 00:01:02:AA:BC:EF)

            frequency - integer - use this frequency (freq in MHz)

            channel - integer - use this channel; will look up the associated
                                frequency and use that for connection

            If frequency and channel are both given, an exception is raised.
        """
        pass

    def disconnect():
        """ Disconnect from currently connected SSID.
        """
        pass

====WirelessConfig Class====

The WirelessConfig class is a subclass of Wireless that aims to contain more
of the information and commands available under each protocol.  Because each
protocol provides a slightly different set of information and commands, the
methods in WirelessConfig are not guaranteed to be the same in number,
content, nor function.

=====WirelessConfig Common Methods=====

The methods listed here are those which will be in both packages'
WirelessConfig.  Package-specific methods are given after this section and
are in addition to the API detailed here.

{{{
class WirelessConfig(Wireless):
    def get_ssid():
        """ Return the currently connected SSID.  Returns None if no
            connection is in place.
        """
        return string

    def set_ssid(ssid):
        """ Set the SSID to ssid.

            ssid - string - the desired SSID

            Raises an exception if interface is connected, as changing the
            SSID while connected would break the connection.
        """
        pass

    def get_bssid():
        """ Return the currently connected BSSID as a string of six
            colon-separated octets (e.g. 00:01:02:AA:BC:EF).  Returns None
            if no connection is in place.
        """
        return string

    def set_bssid(bssid):
        """ Set the BSSID to bssid.

            bssid - string - the deisred BSSID

            Changing the BSSID while connected may break the connection.
        """
        pass

    def get_frequency():
        """ Return the current frequency in MHz (e.g. 2462).  Returns None
            if no connection is in place.
        """
        return frequency

    def set_frequency(frequency):
        """ Set the frequency.

            frequency - integer - the wireless device's frequency (in MHz).

            Raises an exception if the frequency is not supported.
        """
        pass

    def get_channel():
        """ Return the current channel.  Returns None if no connection is
            in place.
        """
        return channel

    def set_channel(channel):
        """ Set the frequency by looking up the given channel.

            channel - integer - the channel number for the frequency desired

            Raises an exception if the channel cannot be found or the matched
            frequency is not supported.
        """
        pass

    def get_available_modes():
        """ Return a list of the modes available on this device (i.e. IBSS,
            managed, monitor, etc.).
        """
        return mode_list

    def get_mode():
        """ Return the current mode (i.e. IBSS, managed, monitor, etc.)
            in string form.
        """
        return mode

    def set_mode(mode):
        """ Set the mode.

            mode - string - the card mode

            Raises an exception if the mode is not supported.
        """
        pass

    del get_encryption():
        return XXX
    def set_encryption(XXX)
        pass

    def get_available_keys():
        """ Returns a list of the encryption keys in the device.  Returns
            an empty list if no keys are present in the device.
        """
        return key_list

    def get_key(index=0):
        """ Returns an encryption key from the device.  Returns None if no
            key is present in the device.

            index - integer - Up to four keys (0-3) can be stored on the
              device.  get_key() defaults to returning the first key (at
              index 0), but other keys can be selected by choosing a
              different index.

            Raises an exception if 0 <= index <= 3.

            XXX - more detail required
                What format for the key?
        """
        return key

    def add_key(index, key):
        """ Set an encryption key on the device.

            index - integer - The position in which to place the key, see
              get_key() for more information.

            key - the encryption key to add

            Raises an exception if 0 <= index <= 3.

            XXX - more detail required
                What format for the key?
        """
        pass

    def set_key(index, key=None):
        """ Set, and optionally add, the encryption key to use.

            index - integer - The position of the key, see get_key() for
              more information.

            key - (optional) the encryption key to add

            Raises an exception if 0 <= index <= 3.

            XXX - more detail required
                What format for the key?
        """
        pass

    def get_power_save():
        """ Returns the current state of power save; True for power save on
            and False for power save off.
        """
        return power_save

    def set_power_save(power_save):
        """ Set the power save state for the device.

            See WirelessConfig for power options specific to each protocol.
        """
        pass
}}}

=====nl80211 WirelessConfig=====

{{{
class WirelessConfig(Wireless):
    def authenticate(ssid=string, bssid=hex_string, frequency=float,
                        channel=integer, auth_type=XXX, ie=XXX)
    def deauthenticate()
    def associate(ssid=string, bssid=hex_string, frequency=float,
                        channel=integer, auth_type=XXX, ie=XXX)
    def disassociate()
    def get_mesh_path():
        return XXX
    def set_mesh_path(XXX)
    def get_mesh_config():
        return XXX
    def set_mesh_config(XXX)
    def mesh_join(XXX)
    def mesh_leave()
    def get_reg_domain()
        return XXX
    def set_reg_domain(XXX)
    def get_bitrates()
        return XXX
    def set_bitrates(XXX)
    def set_tx_bitrate_mask(XXX)
    def get_tx_power()
        return XXX
    def set_tx_power(XXX)
}}}

=====wext WirelessConfig=====

{{{
class WirelessConfig(Wireless):
    def get_bitrates()
        return XXX
    def set_bitrates(XXX)
    def get_tx_power()
        return XXX
    def set_tx_power(XXX)
    def get_power_management()
        return XXX
    def set_power_management(XXX)
    def commit()
}}}


====ServiceSet Class====

Wireless.scan() in pythonwifi <= 0.5 returns an Iwscan object, which is too
implementation specific.  In wext and nl80211 the result of a scan will be
a list of ServiceSet objects.

The attributes included in the ServiceSet class should be all those returned
by the underlying protocol plus any meta-data likely to be helpful to
wireless client developers.  The amount of information in a ServiceSet depends
on the amount of detail asked.  That is, a scan will return some information
about an SSID which will be placed in a ServiceSet object, but querying that
SSID may place more information in the ServiceSet object.

ServiceSet will be a subclass of the Python dict built-in class.  The nl80211
and wext packages will each implement a custom constructor to make object
creation from the underlying system's data easier.  wext's ServiceSet will
accept an Iwscanresult, while nl80211's ServiceSet will accept the dict
returned by a pymnl AttrParser subclass.

{{{
class ServiceSet(dict):
    def __init__(self, data_str)
}}}

Because ServiceSet is a subclass of dict, attribute access is dict access, e.g.

{{{
    >>> access_point = ServiceSet(Iwscanresult)
    >>> for (key, val) in access_point.items():
    ...     print(key, val)
    ...
    essid WinterPalace
    ap 00:11:22:33:44:55
    mode managed
    etc.
    >>> print('signal', access_point['signal'])
    signal 67
}}}








